#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <ctime>
#include <sstream>
#include <iomanip>
#include <queue>

using namespace std;
#define INF 0x3f3f3f3f

typedef pair<int, int> iPair;
vector<iPair>* graph;

int* weightary;
int* adjmatrix;
bool* confary;
int V, E;

// To add an edge
void addEdge(vector <pair<int, int> > graph[], int u,
    int v, int e)
{
    graph[u].emplace_back(make_pair(v, e));
    graph[v].emplace_back(make_pair(u, e));
}

// Define a structure to represent edges
struct Edge {
    int u, v, weight;

    // Define a custom comparison operator for Edge
    bool operator==(const Edge& other) const {
        return (u == other.u && v == other.v && weight == other.weight);
    }
};

// Create a vector to store the edges
vector<Edge> edges;

// Function to generate a random number between min and max
int random(int min, int max) {
    return min + rand() % (max - min + 1);
}

// Prints shortest paths from src to all other vertices
void primMST(vector<pair<int, int> > graph[])
{
    // Create a priority queue to store vertices that
    // are being primMST. This is weird syntax in C++.
    // Refer below link for details of this syntax
    // https://www.geeksforgeeks.org/implement-min-heap-using-stl/
    priority_queue< iPair, vector <iPair>, greater<iPair> > pq;
    int totalweight = 0;
    int src = 0; // Taking vertex 0 as source

    // Create a vector for keys and initialize all
    // keys as infinite (INF)
    vector<int> key(V, INF);

    // To store parent array which in turn store MST
    vector<int> parent(V, -1);

    // To keep track of vertices included in MST
    vector<bool> inMST(V, false);

    // Insert source itself in priority queue and initialize
    // its key as 0.
    pq.push(make_pair(0, src));
    key[src] = 0;

    /* Looping till priority queue becomes empty */
    while (!pq.empty())
    {
        // The first vertex in pair is the minimum key
        // vertex, extract it from priority queue.
        // vertex label is stored in second of pair (it
        // has to be done this way to keep the vertices
        // sorted key (key must be first item
        // in pair)
        int u = pq.top().second;
        pq.pop();

        //Different key values for same vertex may exist in the priority queue.
        //The one with the least key value is always processed first.
        //Therefore, ignore the rest.
        if (inMST[u] == true) {
            continue;
        }

        inMST[u] = true; // Include vertex in MST

        // Traverse all adjacent of u
        for (auto& x : graph[u])
        {
            // Get vertex label and weight of current adjacent
            // of u.
            int v = x.first;
            int edge = x.second;
            int weight = weightary[edge];

            // If v is not in MST and weight of (u,v) is smaller
            // than current key of v
            if (inMST[v] == false && key[v] > weight)
            {
                // Updating key of v
                key[v] = weight;
                pq.push(make_pair(key[v], v));
                parent[v] = u;
            }
        }
    }

    auto it = ranges::find(inMST, false);
    auto it2 = inMST.end();
    if (it != it2) {
        cout << "The MST relaxation is infeasible!" << endl;
        exit(1);
    }
    else {
        // Print edges of MST using parent array
        for (int i = 1; i < V; ++i) {
            int edge = adjmatrix[i * V + parent[i]];
            edges[edge].weight = 100;
            weightary[edge] = 100;
            cout << edge << " : " << parent[i] << " ---> " << i << " : " << key[i] << endl;
            totalweight += key[i];
        }
    }
}

// Function to generate an MSTC instance and write it to a text file
void generateMSTCInstance(int numVertices, int numEdges, int numConflicts, int randomIndex, const string& directory) {
    stringstream filename;
    filename << directory << numVertices << "_" << numEdges << "_" << numConflicts << "_" << randomIndex << ".txt";

    ofstream outputFile(filename.str());

    if (!outputFile.is_open()) {
        cerr << "Failed to open output file." << endl;
        return;
    }

    srand(randomIndex);

    graph = new vector<iPair>[V];
    int edge = 0;
    // Add remaining edges with weights between 20 and 90
    while (edges.size() < numEdges) {
        Edge e;
        e.u = random(0, numVertices - 1);
        e.v = random(0, numVertices - 1);
        if (adjmatrix[e.u * V + e.v] != -1) continue;
        e.weight = random(20, 90);

        // Avoid self-loops and duplicate edges
        if (e.u != e.v && find(edges.begin(), edges.end(), e) == edges.end()) {
            edges.push_back(e);
            adjmatrix[e.u * V + e.v] = edge;
            adjmatrix[e.v * V + e.u] = edge;
            addEdge(graph, e.u, e.v, edge);
            weightary[edge] = e.weight;
            edge++;
        }
    }

    primMST(graph);
    // Write the number of vertices, edges, and conflicts
    outputFile << numVertices << endl;
    outputFile << numEdges << endl;
    outputFile << numConflicts << endl;

    // Write the edges
    for (const Edge& edge : edges) {
        outputFile << edge.u << " " << edge.v << " " << edge.weight << endl;
    }

    // Add conflicts to the file
    while (numConflicts > 0) {
        int idx1 = random(0, numEdges - 1);
        int idx2 = random(0, numEdges - 1);
        if (idx1 == idx2) continue;
        if (weightary[idx1] == 100 && weightary[idx2] == 100) continue;
        if (confary[idx1 * E + idx2]) continue;
        Edge e1 = edges[idx1];
        Edge e2 = edges[idx2];

        outputFile << e1.u << " " << e1.v << " " << e2.u << " " << e2.v << endl;
        //outputFile << e2.u << " " << e2.v << " " << e1.u << " " << e1.v << endl; // Not necessary, causes symmetry and may result in very large instance size.
        confary[idx1 * E + idx2] = true;
        confary[idx2 * E + idx1] = true;
         numConflicts--;
    }

    outputFile.close();
    cout << "MSTC instance written to " << filename.str() << endl;
}

int main(int argc, char* argv[]) {
    int numVertices, numEdges, numConflicts, randomIndex;
    string directory;

    if (argc == 1) {
        // Input: Number of vertices, edges, conflicts, random index, and directory
        cout << "Enter number of vertices: ";
        cin >> numVertices;

        cout << "Enter number of edges: ";
        cin >> numEdges;

        cout << "Enter number of conflicts: ";
        cin >> numConflicts;

        cout << "Enter random index: ";
        cin >> randomIndex;
    }

    else {
        numVertices = atoi(argv[1]);
        numEdges = atoi(argv[2]);
        numConflicts = atoi(argv[3]);
        randomIndex = atoi(argv[4]);
    }
    V = numVertices;
    E = numEdges;
    weightary = new int[E];
    memset(weightary, 0, E * (sizeof(int)));
    adjmatrix = new int[V * V];
    memset(adjmatrix, -1, (V * V) * (sizeof(int)));
    confary = new bool[E * E];
    memset(confary, 0, (E * E) * (sizeof(bool)));

    directory = "C:\\MSTC\\";
    
    generateMSTCInstance(numVertices, numEdges, numConflicts, randomIndex, directory);

    return 0;
}
